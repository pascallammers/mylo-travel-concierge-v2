---
phase: 02-alternative-airports
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lib/tools/flight-search.ts
  - lib/types.ts
  - components/message-parts/index.tsx
  - components/alternative-airport-selector.tsx
autonomous: true

must_haves:
  truths:
    - "Empty flight search shows alternative airports inline instead of generic error"
    - "User sees max 3 nearby airports with drive time estimates"
    - "Original search params preserved when showing alternatives"
    - "Alternatives only shown for the airport that had no results (origin OR destination)"
    - "User can click alternative airport to trigger confirmation dialog and re-search"
  artifacts:
    - path: "lib/tools/flight-search.ts"
      provides: "Alternative airport integration in no-results handling"
      contains: "getNearbyAirports"
    - path: "components/alternative-airport-selector.tsx"
      provides: "Interactive UI component for alternative airport selection with AlertDialog"
      exports: ["AlternativeAirportSelector"]
  key_links:
    - from: "lib/tools/flight-search.ts"
      to: "lib/api/duffel-client.ts"
      via: "imports getNearbyAirports"
      pattern: "import.*getNearbyAirports.*duffel-client"
    - from: "lib/tools/flight-search.ts"
      to: "lib/utils/tool-error-response.ts"
      via: "imports formatFlightErrorWithAlternatives"
      pattern: "import.*formatFlightErrorWithAlternatives.*tool-error-response"
    - from: "components/message-parts/index.tsx"
      to: "components/alternative-airport-selector.tsx"
      via: "renders AlternativeAirportSelector for flight_search tool invocations with alternatives"
      pattern: "AlternativeAirportSelector"
---

<objective>
Integrate alternative airport suggestions into the flight search tool's "no results" handling and create an interactive UI component for users to click alternatives and re-search with confirmation.

Purpose: Prevent dead-end experiences by offering users actionable alternatives when flights aren't available from their chosen airport. Per CONTEXT.md: "Klick auf Alternative zeigt Bestätigungsdialog."

Output: Updated flight-search.ts that returns structured alternative data, and AlternativeAirportSelector React component with AlertDialog confirmation.
</objective>

<execution_context>
@/Users/pascallammers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pascallammers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-alternative-airports/02-CONTEXT.md
@.planning/phases/02-alternative-airports/02-RESEARCH.md
@.planning/phases/02-alternative-airports/02-01-SUMMARY.md
@lib/tools/flight-search.ts
@lib/api/duffel-client.ts
@lib/utils/tool-error-response.ts
@lib/types.ts
@components/message-parts/index.tsx
@components/ui/alert-dialog.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add imports and update no-results handling in flight-search.ts</name>
  <files>lib/tools/flight-search.ts</files>
  <action>
Integrate alternative airports into the flight search tool:

1. **Add new imports at top of file:**
```typescript
import { getNearbyAirports, NearbyAirport } from '@/lib/api/duffel-client';
import { formatFlightErrorWithAlternatives, AlternativeAirport } from '@/lib/utils/tool-error-response';
```

2. **Update the "no results" handling block** (around line 244-266):

Replace the existing block:
```typescript
if (!hasSeats && !hasDuffel) {
  const errorType = seatsError || duffelError ? 'provider_unavailable' : 'no_results';
  // ... existing error handling
}
```

With enhanced logic:

```typescript
if (!hasSeats && !hasDuffel) {
  // Determine error type
  const errorType = seatsError || duffelError ? 'provider_unavailable' : 'no_results';

  // Only search for alternatives if this is a "no_results" case (not provider failure)
  if (errorType === 'no_results') {
    console.log('[Flight Search] No results, searching for nearby airports...');

    // Determine which airport to find alternatives for
    // Heuristic: If origin is a major hub, likely destination had no flights
    // Otherwise, assume origin needs alternatives
    const majorHubs = ['LHR', 'FRA', 'CDG', 'AMS', 'JFK', 'LAX', 'DXB', 'SIN', 'HKG', 'NRT'];
    const emptyAirportCode = majorHubs.includes(origin) ? destination : origin;
    const emptyAirportType: 'origin' | 'destination' = majorHubs.includes(origin) ? 'destination' : 'origin';

    // Get nearby alternatives
    const nearbyAirports = await getNearbyAirports(emptyAirportCode);

    if (nearbyAirports.length > 0) {
      // Map to AlternativeAirport format
      const alternatives: AlternativeAirport[] = nearbyAirports.map(apt => ({
        code: apt.code,
        name: apt.name,
        city: apt.city,
        distance: apt.driveTime,
      }));

      // Build display name for the empty airport
      const emptyAirportDisplay = emptyAirportType === 'origin'
        ? originDisplay
        : destinationDisplay;

      // Return BOTH the formatted text AND structured data for UI rendering
      const formattedMessage = formatFlightErrorWithAlternatives({
        type: 'no_results',
        message: `Für Ihre Suchkriterien wurden leider keine Flüge gefunden.`,
        alternatives,
        emptyAirport: emptyAirportType,
        originalAirportName: emptyAirportDisplay,
        searchParams: searchLinkParams,
      });

      // Return structured response that can be rendered as interactive UI
      return JSON.stringify({
        type: 'no_results_with_alternatives',
        message: formattedMessage,
        alternatives: alternatives.map(alt => ({
          ...alt,
          originalAirport: emptyAirportCode,
          replaceType: emptyAirportType,
        })),
        originalSearch: {
          origin,
          destination,
          departureDate,
          returnDate,
          passengers,
          cabinClass,
        },
      });
    }

    // No alternatives found - fall through to regular error
    console.log('[Flight Search] No nearby airports found within search radius');
  }

  // Provider failure or no alternatives - use existing error handling
  const technicalDetails =
    seatsError && duffelError
      ? 'Both Seats.aero and Duffel failed'
      : seatsError
        ? 'Seats.aero failed'
        : duffelError
          ? 'Duffel failed'
          : 'No flights matched search criteria';

  return formatGracefulFlightError({
    type: errorType,
    message:
      errorType === 'provider_unavailable'
        ? 'Die Flugsuche konnte keine Ergebnisse laden, da einige unserer Datenquellen vorübergehend nicht erreichbar sind.'
        : 'Keine Flüge gefunden. Versuchen Sie andere Daten.',
    searchParams: searchLinkParams,
    technicalDetails,
  });
}
```

Key implementation notes:
- Major hub heuristic: If origin is a major hub (LHR, FRA, CDG, AMS, JFK, LAX, DXB, SIN, HKG, NRT), assume destination needs alternatives
- This follows CONTEXT.md: "Alternative ersetzt nur den Airport der 'leer' war"
- Return JSON with structured data so frontend can render interactive buttons
- If getNearbyAirports returns empty, fall through to generic error message
- Only search alternatives for 'no_results', not 'provider_unavailable' (no point suggesting alternatives if APIs are down)
- Use originDisplay/destinationDisplay (from resolution) for friendly airport names in message
  </action>
  <verify>
TypeScript compilation passes: `npx tsc --noEmit`
  </verify>
  <done>
Flight search tool returns structured JSON with alternatives when no flights found, including all data needed for interactive UI rendering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add console logging for alternative airport flow</name>
  <files>lib/tools/flight-search.ts</files>
  <action>
Add comprehensive logging for debugging the alternative airport flow:

1. **Add log when alternatives are found:**
After `const nearbyAirports = await getNearbyAirports(emptyAirportCode);`, add:
```typescript
console.log(`[Flight Search] Found ${nearbyAirports.length} nearby airports for ${emptyAirportCode}:`,
  nearbyAirports.map(a => `${a.code} (${a.driveTime})`).join(', '));
```

2. **Add log for which airport was selected:**
After determining emptyAirportCode, add:
```typescript
console.log(`[Flight Search] Looking for alternatives to ${emptyAirportType}: ${emptyAirportCode}`);
```

3. **Update the success case log:**
After mapping to alternatives, before return:
```typescript
console.log('[Flight Search] Returning alternatives response with interactive UI data');
```

These logs help debug:
- Which airport the system decided needed alternatives
- How many alternatives were found
- Which codes and drive times are being returned
  </action>
  <verify>
TypeScript compilation passes: `npx tsc --noEmit`
  </verify>
  <done>
Console logs provide clear visibility into the alternative airport selection and results for debugging.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AlternativeAirportSelector component with AlertDialog confirmation</name>
  <files>components/alternative-airport-selector.tsx, components/message-parts/index.tsx, lib/types.ts</files>
  <action>
Create an interactive component for selecting alternative airports with confirmation dialog.

**Step 1: Add type for alternative airports response in lib/types.ts:**

Add new type after existing flight-related types:
```typescript
export interface AlternativeAirportResponse {
  type: 'no_results_with_alternatives';
  message: string;
  alternatives: Array<{
    code: string;
    name: string;
    city: string;
    distance: string;
    originalAirport: string;
    replaceType: 'origin' | 'destination';
  }>;
  originalSearch: {
    origin: string;
    destination: string;
    departureDate: string;
    returnDate?: string;
    passengers: number;
    cabinClass: string;
  };
}
```

**Step 2: Create components/alternative-airport-selector.tsx:**

```typescript
'use client';

import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Plane, Clock } from 'lucide-react';
import { AlternativeAirportResponse } from '@/lib/types';

interface AlternativeAirportSelectorProps {
  data: AlternativeAirportResponse;
  onSelectAirport: (newSearch: string) => void;
}

export function AlternativeAirportSelector({
  data,
  onSelectAirport,
}: AlternativeAirportSelectorProps) {
  const [selectedAlternative, setSelectedAlternative] = useState<{
    code: string;
    name: string;
    city: string;
  } | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  const handleAirportClick = (alt: typeof data.alternatives[0]) => {
    setSelectedAlternative({ code: alt.code, name: alt.name, city: alt.city });
    setIsDialogOpen(true);
  };

  const handleConfirm = () => {
    if (!selectedAlternative) return;

    // Build new search query
    const { originalSearch, alternatives } = data;
    const selectedAlt = alternatives.find(a => a.code === selectedAlternative.code);

    if (!selectedAlt) return;

    // Replace the appropriate airport
    const newOrigin = selectedAlt.replaceType === 'origin'
      ? selectedAlternative.code
      : originalSearch.origin;
    const newDestination = selectedAlt.replaceType === 'destination'
      ? selectedAlternative.code
      : originalSearch.destination;

    // Build natural language search query
    const searchQuery = `Flüge von ${newOrigin} nach ${newDestination} am ${originalSearch.departureDate}${
      originalSearch.returnDate ? ` (Rückflug: ${originalSearch.returnDate})` : ''
    }, ${originalSearch.passengers} ${originalSearch.passengers === 1 ? 'Person' : 'Personen'}, ${originalSearch.cabinClass}`;

    onSelectAirport(searchQuery);
    setIsDialogOpen(false);
    setSelectedAlternative(null);
  };

  return (
    <div className="mt-4">
      {/* Render the formatted message as markdown would be rendered by parent */}

      {/* Alternative airport buttons */}
      <div className="space-y-2 mt-4">
        <p className="text-sm font-medium text-muted-foreground mb-2">
          Diese Flughäfen sind in der Nähe:
        </p>
        {data.alternatives.map((alt) => (
          <Button
            key={alt.code}
            variant="outline"
            className="w-full justify-start gap-3 h-auto py-3 px-4"
            onClick={() => handleAirportClick(alt)}
          >
            <Plane className="h-4 w-4 flex-shrink-0 text-primary" />
            <div className="flex flex-col items-start text-left">
              <span className="font-medium">
                {alt.city} — {alt.name} ({alt.code})
              </span>
              <span className="text-sm text-muted-foreground flex items-center gap-1">
                <Clock className="h-3 w-3" />
                {alt.distance}
              </span>
            </div>
          </Button>
        ))}
      </div>

      {/* Confirmation Dialog */}
      <AlertDialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Suche mit anderem Flughafen?</AlertDialogTitle>
            <AlertDialogDescription>
              {selectedAlternative && (
                <>
                  Mit <strong>{selectedAlternative.city} ({selectedAlternative.code})</strong> statt{' '}
                  <strong>{data.alternatives[0]?.originalAirport}</strong> suchen?
                </>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Abbrechen</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirm}>
              Suche starten
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
```

**Step 3: Integrate into message-parts/index.tsx:**

1. Add lazy import near other tool component imports:
```typescript
const AlternativeAirportSelector = lazy(() =>
  import('@/components/alternative-airport-selector').then((module) => ({
    default: module.AlternativeAirportSelector
  })),
);
```

2. In the flight_search tool result handling section (find where flightSearchTool results are rendered), add detection for alternatives response:

```typescript
// Inside the tool result rendering for flight_search
if (toolName === 'flight_search') {
  // Try to parse as alternatives response
  try {
    const parsed = JSON.parse(result);
    if (parsed.type === 'no_results_with_alternatives') {
      return (
        <Suspense fallback={<SearchLoadingState tool="flight_search" />}>
          <AlternativeAirportSelector
            data={parsed}
            onSelectAirport={(query) => {
              // Use sendMessage from parent context to trigger new search
              // This will be passed down through props
              if (onSendMessage) {
                onSendMessage(query);
              }
            }}
          />
        </Suspense>
      );
    }
  } catch {
    // Not JSON, render as regular markdown
  }

  // Fallback to regular markdown rendering
  return <MarkdownRenderer content={result} />;
}
```

3. Ensure `onSendMessage` prop is threaded through from parent components (chat-interface -> messages -> message-parts). Check existing patterns for how `sendMessage` is passed to child components (like suggestedQuestions handler in message.tsx).

Key implementation notes per CONTEXT.md:
- "Klick auf Alternative zeigt Bestätigungsdialog" -> AlertDialog with confirmation
- "Mit [Alternative] statt [Original] suchen?" -> Dialog text format
- "Nur ein Airport pro Suche (kein Multi-Select)" -> Single selection only
- "Alternative ersetzt nur den Airport der 'leer' war" -> replaceType determines which airport to swap
- "Ursprüngliche Suche bleibt im Formular sichtbar" -> We preserve original params in state
  </action>
  <verify>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. Component renders without errors in dev mode
3. Clicking an alternative opens the confirmation dialog
4. Confirming triggers a new search message
  </verify>
  <done>
Interactive AlternativeAirportSelector component:
- Renders clickable buttons for each alternative airport
- Opens AlertDialog confirmation on click ("Mit [Alternative] statt [Original] suchen?")
- On confirm, triggers new flight search via sendMessage
- Follows all CONTEXT.md locked decisions for interaction flow
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. Flight search tool imports getNearbyAirports and formatFlightErrorWithAlternatives
3. No-results handling includes alternative airport search and returns structured JSON
4. Major hub heuristic correctly identifies which airport needs alternatives
5. Console logs provide debugging visibility
6. AlternativeAirportSelector component renders clickable airport buttons
7. AlertDialog appears on button click with correct confirmation text
8. Confirming dialog triggers new search with substituted airport
</verification>

<success_criteria>
- Flight search with no results shows alternative airports inline
- Alternatives include city, name, code, and drive time
- Message is in German with proper formatting (em-dashes)
- Only one airport (origin OR destination) gets alternatives, not both
- If no alternatives found, falls back to generic "no flights" message
- Console logs show the alternative search flow for debugging
- User can click an alternative to open confirmation dialog
- Confirmation dialog asks "Mit [Alternative] statt [Original] suchen?"
- Confirming triggers a new flight search with the alternative airport
- This satisfies Phase Success Criteria 3: "User can click to re-search with alternative airport"
</success_criteria>

<output>
After completion, create `.planning/phases/02-alternative-airports/02-02-SUMMARY.md`
</output>
