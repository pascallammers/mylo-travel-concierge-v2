---
phase: 03-observability-enhancement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/api/duffel-client.ts
  - lib/tools/flight-search.ts
  - lib/types.ts
  - components/flexible-date-selector.tsx
  - components/message-parts/index.tsx
  - components/flight-card.tsx
autonomous: true

must_haves:
  truths:
    - "Empty flight search offers flexible date option before showing generic error"
    - "User can opt-in to search +/- 3 days (7-day window)"
    - "Flexible search returns top 10 results across all 7 days"
    - "Each flight in results shows departure date prominently"
    - "Seats.aero uses native flexibility parameter, Duffel uses batched parallel requests"
  artifacts:
    - path: "lib/api/duffel-client.ts"
      provides: "searchDuffelFlexibleDates helper with Promise.allSettled batching"
      exports: ["searchDuffelFlexibleDates"]
    - path: "lib/tools/flight-search.ts"
      provides: "Flexible date fallback logic in no-results handler"
      contains: "no_results_offer_flexible"
    - path: "components/flexible-date-selector.tsx"
      provides: "Interactive UI for flexible date search opt-in"
      exports: ["FlexibleDateSelector"]
  key_links:
    - from: "lib/tools/flight-search.ts"
      to: "lib/api/duffel-client.ts"
      via: "imports searchDuffelFlexibleDates"
      pattern: "import.*searchDuffelFlexibleDates.*duffel-client"
    - from: "lib/tools/flight-search.ts"
      to: "lib/api/seats-aero-client.ts"
      via: "passes flexibility: 3 parameter"
      pattern: "flexibility:\\s*3"
    - from: "components/message-parts/index.tsx"
      to: "components/flexible-date-selector.tsx"
      via: "renders FlexibleDateSelector for no_results_offer_flexible type"
      pattern: "FlexibleDateSelector"
    - from: "components/message-parts/index.tsx"
      to: "components/flight-card.tsx"
      via: "renders FlightCard with dateLabel and searchedDate props for flexible_date_results"
      pattern: "flexible_date_results.*FlightCard.*dateLabel"
---

<objective>
Implement flexible date search (+/- 3 days) as a fallback when flight search returns no results.

Purpose: Help users find flights even when their exact date has no availability. Per CONTEXT.md: "Aktivierung: Automatisch bei 0 Ergebnissen anbieten (nicht proaktiv im Formular)"

Output:
- searchDuffelFlexibleDates() helper with batched parallel requests (max 3 concurrent)
- Updated flight-search.ts that offers flexible dates before showing generic error
- FlexibleDateSelector component following Phase 2 alternative airports UX pattern
</objective>

<execution_context>
@/Users/pascallammers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pascallammers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-observability-enhancement/03-CONTEXT.md
@.planning/phases/03-observability-enhancement/03-RESEARCH.md
@.planning/phases/02-alternative-airports/02-02-PLAN.md
@lib/tools/flight-search.ts
@lib/api/duffel-client.ts
@lib/api/seats-aero-client.ts
@lib/types.ts
@components/message-parts/index.tsx
@components/alternative-airport-selector.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add searchDuffelFlexibleDates helper to duffel-client.ts</name>
  <files>lib/api/duffel-client.ts</files>
  <action>
Add a new function `searchDuffelFlexibleDates` that searches across a date range with batched parallel requests.

1. **Add the helper function after the existing searchDuffel function:**

```typescript
/**
 * Search Duffel across flexible date range with batched parallelism
 * @param params - Base search parameters
 * @param flexDays - Days to search before and after (default: 3)
 * @returns Array of flights with searchedDate metadata
 */
export async function searchDuffelFlexibleDates(
  params: DuffelSearchParams,
  flexDays: number = 3
): Promise<(DuffelFlight & { searchedDate: string })[]> {
  const baseDate = new Date(params.departureDate);
  const dates: string[] = [];

  // Generate date range (+/- flexDays, excluding original date already searched)
  for (let offset = -flexDays; offset <= flexDays; offset++) {
    if (offset === 0) continue; // Skip original date
    const date = new Date(baseDate);
    date.setDate(date.getDate() + offset);
    dates.push(date.toISOString().split('T')[0]);
  }

  console.log(`[Duffel] Searching ${dates.length} flexible dates with concurrency limit`);

  const results: (DuffelFlight & { searchedDate: string })[] = [];
  const batchSize = 3; // Max 3 concurrent requests to respect rate limits

  for (let i = 0; i < dates.length; i += batchSize) {
    const batch = dates.slice(i, i + batchSize);
    console.log(`[Duffel] Processing batch ${Math.floor(i/batchSize) + 1}: ${batch.join(', ')}`);

    const promises = batch.map(date =>
      searchDuffel({ ...params, departureDate: date })
        .then(flights => flights.map(f => ({ ...f, searchedDate: date })))
        .catch(err => {
          console.warn(`[Duffel] Date ${date} failed:`, err.message);
          return []; // Return empty array on failure
        })
    );

    const batchResults = await Promise.allSettled(promises);

    // Extract successful results
    batchResults.forEach((result) => {
      if (result.status === 'fulfilled') {
        results.push(...result.value);
      }
    });

    // Small delay between batches to be respectful to API
    if (i + batchSize < dates.length) {
      await new Promise(resolve => setTimeout(resolve, 500));
    }
  }

  console.log(`[Duffel] Flexible search complete: ${results.length} total flights`);
  return results;
}
```

Key implementation notes:
- Max 3 concurrent requests per batch to respect Duffel rate limits
- Each flight tagged with `searchedDate` for UI display
- Promise.allSettled ensures partial failures don't crash entire search
- 500ms delay between batches for API courtesy
- Returns empty array on individual date failure (graceful degradation)
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit lib/api/duffel-client.ts`</verify>
  <done>searchDuffelFlexibleDates exported with batched parallel search, max 3 concurrent requests, and searchedDate metadata</done>
</task>

<task type="auto">
  <name>Task 2: Add flexible date response type and update flight-search.ts</name>
  <files>lib/types.ts, lib/tools/flight-search.ts</files>
  <action>
1. **Add FlexibleDateResponse type in lib/types.ts** (after AlternativeAirportResponse):

```typescript
export interface FlexibleDateResponse {
  type: 'no_results_offer_flexible';
  message: string;
  originalSearch: {
    origin: string;
    destination: string;
    departureDate: string;
    returnDate?: string;
    passengers: number;
    cabinClass: string;
    originDisplay: string;
    destinationDisplay: string;
  };
}

export interface FlexibleDateResultsResponse {
  type: 'flexible_date_results';
  flights: Array<{
    // Include all DuffelFlight/SeatsAeroFlight fields plus:
    searchedDate: string;
    dateOffset: number; // -3 to +3
    dateLabel: string;  // "3 Tage frueher" or "2 Tage spaeter"
  }>;
  originalDate: string;
  dateRange: { start: string; end: string };
}
```

2. **Update lib/tools/flight-search.ts** - Add import at top:

```typescript
import { searchDuffelFlexibleDates } from '@/lib/api/duffel-client';
```

3. **In the no-results handler** (inside `if (!hasSeats && !hasDuffel)` block), modify to offer flexible dates BEFORE searching alternatives.

**FULL FALLBACK CHAIN (must be preserved):**
```
Exact Search -> No Results -> Offer Flexible Dates
                                    |
                              User Accepts
                                    |
                                    v
                        Flexible Search (Seats.aero flex=3, Duffel batched)
                                    |
                     +------ Has Results? ------+
                     |                          |
                    YES                         NO
                     |                          |
                     v                          v
        Return flexible_date_results    Alternative Airports (Phase 2)
                                               |
                                  +--- Has Alternatives? ---+
                                  |                         |
                                 YES                        NO
                                  |                         |
                                  v                         v
                    Return no_results_with_alternatives   Generic Error
```

Find the existing block that starts with:
```typescript
if (errorType === 'no_results') {
  console.log('[Flight Search] No results, searching for nearby airports...');
```

Replace the entire `if (errorType === 'no_results')` block with:

```typescript
if (errorType === 'no_results') {
  console.log('[Flight Search] No results found, checking fallback chain...');

  // Check if this is already a flexible date search (avoid infinite loop)
  const isFlexibleSearch = params.flexibility && params.flexibility > 0;

  if (!isFlexibleSearch) {
    // STEP 1: First attempt - Offer flexible date search to user
    console.log('[Flight Search] Returning flexible date offer to user');

    return JSON.stringify({
      type: 'no_results_offer_flexible',
      message: `Fuer Ihre Suche am ${params.departDate} wurden keine Fluege gefunden. Moechten Sie auch +/- 3 Tage suchen?`,
      originalSearch: {
        origin,
        destination,
        departureDate: params.departDate,
        returnDate: params.returnDate,
        passengers: params.passengers,
        cabinClass: params.cabin,
        originDisplay,
        destinationDisplay,
      },
    });
  }

  // STEP 2: If already flexible search with no results, try alternative airports (Phase 2 functionality)
  console.log('[Flight Search] Flexible search had no results, falling back to alternative airports...');

  // [Phase 2 alternative airports logic - MUST be preserved]
  const majorHubs = ['LHR', 'FRA', 'CDG', 'AMS', 'JFK', 'LAX', 'DXB', 'SIN', 'HKG', 'NRT'];
  const emptyAirportCode = majorHubs.includes(origin) ? destination : origin;
  const emptyAirportType: 'origin' | 'destination' = majorHubs.includes(origin) ? 'destination' : 'origin';

  console.log(`[Flight Search] Looking for alternatives to ${emptyAirportType}: ${emptyAirportCode}`);

  const nearbyAirports = await getNearbyAirports(emptyAirportCode);

  console.log(`[Flight Search] Found ${nearbyAirports.length} nearby airports for ${emptyAirportCode}:`,
    nearbyAirports.map(a => `${a.code} (${a.driveTime})`).join(', '));

  if (nearbyAirports.length > 0) {
    // STEP 3: Return alternative airports if found
    const alternatives: AlternativeAirport[] = nearbyAirports.map(apt => ({
      code: apt.code,
      name: apt.name,
      city: apt.city,
      distance: apt.driveTime,
    }));

    const emptyAirportDisplay = emptyAirportType === 'origin'
      ? originDisplay
      : destinationDisplay;

    const formattedMessage = formatFlightErrorWithAlternatives({
      type: 'no_results',
      message: `Fuer Ihre Suchkriterien wurden leider keine Fluege gefunden.`,
      alternatives,
      emptyAirport: emptyAirportType,
      originalAirportName: emptyAirportDisplay,
      searchParams: searchLinkParams,
    });

    console.log('[Flight Search] Returning alternatives response with interactive UI data');

    return JSON.stringify({
      type: 'no_results_with_alternatives',
      message: formattedMessage,
      alternatives: alternatives.map(alt => ({
        ...alt,
        originalAirport: emptyAirportCode,
        replaceType: emptyAirportType,
      })),
      originalSearch: {
        origin,
        destination,
        departureDate: params.departDate,
        returnDate: params.returnDate,
        passengers: params.passengers,
        cabinClass: params.cabin,
      },
    });
  }

  // STEP 4: No alternatives found - fall through to generic error
  console.log('[Flight Search] No nearby airports found, returning generic error');
}
```

**Where flexible search actually happens (user accepts offer):**

When user clicks "Mit flexiblen Daten suchen", the FlexibleDateSelector component triggers a new search message. The flight-search tool then:

1. Detects "mit flexiblen Daten" in query text
2. Calls `searchSeatsAero` with `{ ...params, flexibility: 3 }` (see Step 4 below)
3. Calls `searchDuffelFlexibleDates` in parallel
4. If results found -> returns `flexible_date_results` (Task 4 handles this)
5. If no results -> enters the `if (errorType === 'no_results')` block above with `isFlexibleSearch = true`

4. **Add Seats.aero flexibility parameter** - Find the `searchSeatsAero` call (around line ~180 in the search execution block) and modify:

```typescript
// BEFORE (existing code):
const seatsResults = seatsEnabled ? await searchSeatsAero(seatsParams) : null;

// AFTER (with flexible dates support):
// Detect flexible date search from query or params
const isFlexibleDateSearch = fullQuery.includes('flexiblen Daten') || params.flexibility === 3;

const seatsParams: SeatsAeroSearchParams = {
  origin,
  destination,
  departDate: params.departDate,
  returnDate: params.returnDate || undefined,
  cabin: params.cabin,
  // Add flexibility: 3 for Seats.aero native flexible date support
  ...(isFlexibleDateSearch && { flexibility: 3 }),
};

const seatsResults = seatsEnabled ? await searchSeatsAero(seatsParams) : null;
```

This ensures Seats.aero uses its native `flexibility` parameter (returns +/- 3 days in single request).
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit`</verify>
  <done>Flight search offers flexible dates before alternatives, types exported for UI rendering</done>
</task>

<task type="auto">
  <name>Task 3: Create FlexibleDateSelector component and integrate in message-parts</name>
  <files>components/flexible-date-selector.tsx, components/message-parts/index.tsx</files>
  <action>
Create an interactive component for accepting flexible date search, following Phase 2 AlternativeAirportSelector pattern.

1. **Create components/flexible-date-selector.tsx:**

```typescript
'use client';

import React from 'react';
import { Button } from '@/components/ui/button';
import { Calendar, Search } from 'lucide-react';
import { FlexibleDateResponse } from '@/lib/types';

interface FlexibleDateSelectorProps {
  data: FlexibleDateResponse;
  onAcceptFlexible: (searchQuery: string) => void;
}

export function FlexibleDateSelector({
  data,
  onAcceptFlexible,
}: FlexibleDateSelectorProps) {
  const handleAccept = () => {
    // Build search query that includes flexibility parameter
    const { originalSearch } = data;

    // Calculate date range for display
    const baseDate = new Date(originalSearch.departureDate);
    const startDate = new Date(baseDate);
    const endDate = new Date(baseDate);
    startDate.setDate(startDate.getDate() - 3);
    endDate.setDate(endDate.getDate() + 3);

    const formatDate = (d: Date) => d.toLocaleDateString('de-DE', {
      day: '2-digit',
      month: '2-digit',
    });

    // Build natural language search query with flexible dates hint
    const searchQuery = `Fluege von ${originalSearch.originDisplay} nach ${originalSearch.destinationDisplay} zwischen ${formatDate(startDate)} und ${formatDate(endDate)}${
      originalSearch.returnDate ? ` (Rueckflug: ${originalSearch.returnDate})` : ''
    }, ${originalSearch.passengers} ${originalSearch.passengers === 1 ? 'Person' : 'Personen'}, ${originalSearch.cabinClass}, mit flexiblen Daten`;

    onAcceptFlexible(searchQuery);
  };

  // Format the original date for display
  const formattedDate = new Date(data.originalSearch.departureDate).toLocaleDateString('de-DE', {
    weekday: 'long',
    day: '2-digit',
    month: 'long',
    year: 'numeric',
  });

  return (
    <div className="mt-4 space-y-4">
      {/* Info message */}
      <div className="flex items-start gap-3 p-4 bg-muted/50 rounded-lg">
        <Calendar className="h-5 w-5 text-primary flex-shrink-0 mt-0.5" />
        <div>
          <p className="text-sm font-medium">
            Keine Fluege am {formattedDate}
          </p>
          <p className="text-sm text-muted-foreground mt-1">
            Moechten Sie auch 3 Tage davor und danach suchen?
          </p>
        </div>
      </div>

      {/* Action buttons */}
      <div className="flex gap-3">
        <Button
          onClick={handleAccept}
          className="flex-1 gap-2"
        >
          <Search className="h-4 w-4" />
          Mit flexiblen Daten suchen
        </Button>
      </div>

      {/* Route summary */}
      <p className="text-xs text-muted-foreground text-center">
        {data.originalSearch.originDisplay} &rarr; {data.originalSearch.destinationDisplay}
      </p>
    </div>
  );
}
```

2. **Integrate into components/message-parts/index.tsx:**

Add lazy import near other tool component imports (find AlternativeAirportSelector import):
```typescript
const FlexibleDateSelector = lazy(() =>
  import('@/components/flexible-date-selector').then((module) => ({
    default: module.FlexibleDateSelector
  })),
);
```

In the flight_search tool result handling section (find where AlternativeAirportSelector is rendered), add detection for flexible date response BEFORE the alternatives check:

```typescript
// Inside the tool result rendering for flight_search
if (toolName === 'flight_search') {
  try {
    const parsed = JSON.parse(result);

    // Check for flexible date offer (before alternatives check)
    if (parsed.type === 'no_results_offer_flexible') {
      return (
        <Suspense fallback={<SearchLoadingState tool="flight_search" />}>
          <FlexibleDateSelector
            data={parsed}
            onAcceptFlexible={(query) => {
              if (onSendMessage) {
                onSendMessage(query);
              }
            }}
          />
        </Suspense>
      );
    }

    // Existing alternatives check
    if (parsed.type === 'no_results_with_alternatives') {
      return (
        <Suspense fallback={<SearchLoadingState tool="flight_search" />}>
          <AlternativeAirportSelector
            data={parsed}
            onSelectAirport={(query) => {
              if (onSendMessage) {
                onSendMessage(query);
              }
            }}
          />
        </Suspense>
      );
    }
  } catch {
    // Not JSON, render as regular markdown
  }

  // Fallback to regular markdown rendering
  return <MarkdownRenderer content={result} />;
}
```

Key implementation notes per CONTEXT.md:
- "Aktivierung: Automatisch bei 0 Ergebnissen anbieten" -> Component shown inline (not dialog) following Phase 2 pattern
- "Datumsbereich: +/-3 Tage (7-Tage-Fenster)" -> Display shows date range context
- "UI-Praesentation: Claude's Discretion (konsistent mit Phase 2)" -> Uses similar card/button pattern as AlternativeAirportSelector
- German UI text matches existing patterns
  </action>
  <verify>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. Component renders without errors in dev mode
3. Clicking "Mit flexiblen Daten suchen" triggers new search message
  </verify>
  <done>
FlexibleDateSelector component:
- Shows when flight search returns no results (before alternatives)
- Inline card with calendar icon and flexible date offer
- Click triggers new search with flexibility parameter
- Follows Phase 2 UX pattern for consistency
  </done>
</task>

<task type="auto">
  <name>Task 4: Process and display flexible date results with date labels</name>
  <files>lib/tools/flight-search.ts, components/flight-card.tsx, components/message-parts/index.tsx</files>
  <action>
Per CONTEXT.md: "Sortierung: Kombiniert — Datum sichtbar + Preis-Badge zeigt günstigere Tage" and "Maximum: Top 10 Flüge gesamt über alle 7 Tage"

1. **In lib/tools/flight-search.ts** - Add result processing for flexible search results.

Find where `seatsResults` and `duffelResults` are merged (around line ~210), and add flexible date result processing:

```typescript
// After merging results but before returning:

if (isFlexibleDateSearch && allFlights.length > 0) {
  console.log(`[Flight Search] Processing ${allFlights.length} flexible date results`);

  // Add date metadata to each flight
  const flightsWithDateLabels = allFlights.map(flight => {
    const searchedDate = flight.searchedDate || flight.departureDate || params.departDate;
    const originalDate = new Date(params.departDate);
    const flightDate = new Date(searchedDate);
    const daysDiff = Math.round((flightDate.getTime() - originalDate.getTime()) / (1000 * 60 * 60 * 24));

    let dateLabel: string;
    if (daysDiff === 0) {
      dateLabel = 'Originaldatum';
    } else if (daysDiff < 0) {
      dateLabel = `${Math.abs(daysDiff)} ${Math.abs(daysDiff) === 1 ? 'Tag' : 'Tage'} frueher`;
    } else {
      dateLabel = `${daysDiff} ${daysDiff === 1 ? 'Tag' : 'Tage'} spaeter`;
    }

    return {
      ...flight,
      searchedDate,
      dateOffset: daysDiff,
      dateLabel,
    };
  });

  // Sort by price (lowest first) - per CONTEXT.md "Preis-Badge zeigt günstigere Tage"
  flightsWithDateLabels.sort((a, b) => {
    const priceA = a.price || a.points || 0;
    const priceB = b.price || b.points || 0;
    return priceA - priceB;
  });

  // Limit to top 10 per CONTEXT.md
  const top10 = flightsWithDateLabels.slice(0, 10);

  console.log(`[Flight Search] Returning top ${top10.length} flexible date results`);

  return JSON.stringify({
    type: 'flexible_date_results',
    flights: top10,
    originalDate: params.departDate,
    dateRange: {
      start: new Date(new Date(params.departDate).getTime() - 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
      end: new Date(new Date(params.departDate).getTime() + 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
    },
  });
}
```

2. **In components/flight-card.tsx** - Add date badge display.

Find the existing price/points badge display and add date label badge nearby:

```typescript
// Add prop to FlightCardProps interface:
interface FlightCardProps {
  // ... existing props
  dateLabel?: string;
  searchedDate?: string;
}

// In the card header/meta section, add date display:
{dateLabel && (
  <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">
    {dateLabel}
  </span>
)}

// Show searchedDate prominently in the departure section:
{searchedDate && (
  <p className="text-sm font-medium text-primary">
    {new Date(searchedDate).toLocaleDateString('de-DE', {
      weekday: 'short',
      day: '2-digit',
      month: 'short',
    })}
  </p>
)}
```

3. **In components/message-parts/index.tsx** - Add handler for flexible_date_results type.

After the `no_results_offer_flexible` check, add:

```typescript
// Check for flexible date search results
if (parsed.type === 'flexible_date_results') {
  return (
    <div className="space-y-4">
      <div className="flex items-center gap-2 text-sm text-muted-foreground">
        <Calendar className="h-4 w-4" />
        <span>
          Ergebnisse vom {new Date(parsed.dateRange.start).toLocaleDateString('de-DE')} bis{' '}
          {new Date(parsed.dateRange.end).toLocaleDateString('de-DE')}
        </span>
      </div>
      <div className="space-y-3">
        {parsed.flights.map((flight: any, idx: number) => (
          <FlightCard
            key={flight.id || idx}
            {...flight}
            dateLabel={flight.dateLabel}
            searchedDate={flight.searchedDate}
          />
        ))}
      </div>
      {parsed.flights.length === 10 && (
        <p className="text-xs text-muted-foreground text-center">
          Top 10 Ergebnisse angezeigt (sortiert nach Preis)
        </p>
      )}
    </div>
  );
}
```

Add import at top if needed:
```typescript
import { Calendar } from 'lucide-react';
```

Key implementation per CONTEXT.md:
- "Datum sichtbar + Preis-Badge zeigt günstigere Tage" -> dateLabel shows relative date, sorted by price
- "Maximum: Top 10 Flüge gesamt über alle 7 Tage" -> slice(0, 10) applied
- "Kommunikation: Inline bei jedem Flug (Datum prominent)" -> searchedDate displayed prominently on each card
  </action>
  <verify>
1. TypeScript compilation passes: `npx tsc --noEmit`
2. Flexible search with results shows date labels on cards
3. Results sorted by price with top 10 limit
4. Date range header visible above results
  </verify>
  <done>
Flexible date results display:
- Each flight card shows searchedDate prominently
- dateLabel badge shows "2 Tage frueher" / "3 Tage spaeter" etc.
- Results sorted by price (cheapest first)
- Limited to top 10 across all 7 days
- Date range header provides context
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `npx tsc --noEmit`
2. searchDuffelFlexibleDates exported from duffel-client.ts
3. FlexibleDateResponse type exported from lib/types.ts
4. Flight search returns `no_results_offer_flexible` when exact date has no results
5. FlexibleDateSelector component renders inline offer with accept button
6. Accepting triggers new search that includes flexibility parameter
7. Fallback chain works: Exact -> Offer Flexible -> Alternatives -> Generic Error
</verification>

<success_criteria>
- User searches exact date with no results: sees "Mit flexiblen Daten suchen?" offer
- Clicking offer triggers search with +/- 3 day range
- Seats.aero receives flexibility: 3 parameter (native support)
- Duffel uses searchDuffelFlexibleDates with max 3 concurrent requests
- If flexible search also has no results, falls through to alternative airports
- Each flexible date result shows departure date prominently
- Top 10 results across all 7 days (sorted by price per CONTEXT.md)
- This satisfies Roadmap criteria 3 & 4: User can opt-in to flexible dates, returns 7-day window results
</success_criteria>

<output>
After completion, create `.planning/phases/03-observability-enhancement/03-02-SUMMARY.md`
</output>
