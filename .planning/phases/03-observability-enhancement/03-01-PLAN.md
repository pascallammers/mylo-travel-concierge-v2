---
phase: 03-observability-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/db/queries/failed-search.ts
  - lib/tools/flight-search.ts
  - app/api/cron/cleanup-failed-searches/route.ts
  - app/api/admin/failed-searches/route.ts
  - app/admin/failed-searches/page.tsx
  - vercel.json
autonomous: true

must_haves:
  truths:
    - "Failed searches are logged with query text, IATA codes, date, timestamp"
    - "Admin sees only recent failed searches (last 30 days)"
    - "Admin can view failed search logs with date range and text filters"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "failedSearchLogs table definition"
      contains: "failedSearchLogs"
    - path: "lib/db/queries/failed-search.ts"
      provides: "CRUD operations for failed search logs"
      exports: ["logFailedSearch", "getFailedSearchLogs", "deleteExpiredLogs"]
    - path: "app/admin/failed-searches/page.tsx"
      provides: "Admin UI for viewing logs"
      min_lines: 80
  key_links:
    - from: "lib/tools/flight-search.ts"
      to: "lib/db/queries/failed-search.ts"
      via: "logFailedSearch() call in no-results handler"
      pattern: "logFailedSearch"
    - from: "app/api/cron/cleanup-failed-searches/route.ts"
      to: "lib/db/queries/failed-search.ts"
      via: "deleteExpiredLogs() call"
      pattern: "deleteExpiredLogs"
---

<objective>
Implement failed search logging for monitoring flight search failures.

Purpose: Track when and why flight searches return no results, enabling admins to identify patterns and improve the system proactively.

Output:
- Database table for failed search logs with 30-day TTL
- Integration in flight-search.ts to log failures
- Vercel Cron job for automatic cleanup
- Admin UI page with filtering capabilities
</objective>

<execution_context>
@/Users/pascallammers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pascallammers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-observability-enhancement/03-CONTEXT.md
@.planning/phases/03-observability-enhancement/03-RESEARCH.md
@lib/db/schema.ts
@lib/tools/flight-search.ts
@app/admin/layout.tsx
@vercel.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add failedSearchLogs schema and query functions</name>
  <files>lib/db/schema.ts, lib/db/queries/failed-search.ts</files>
  <action>
1. In `lib/db/schema.ts`, add the failedSearchLogs table after the existing tables:

```typescript
// Failed Search Logs for monitoring and pattern analysis
export const failedSearchLogs = pgTable('failed_search_logs', {
  id: text('id')
    .primaryKey()
    .$defaultFn(() => generateId()),
  chatId: text('chat_id')
    .notNull()
    .references(() => chat.id, { onDelete: 'cascade' }),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),

  // Query data
  queryText: text('query_text').notNull(),
  extractedOrigin: text('extracted_origin'),
  extractedDestination: text('extracted_destination'),
  departDate: text('depart_date'),
  returnDate: text('return_date'),
  cabin: text('cabin'),

  // Context
  resultCount: integer('result_count').notNull().default(0),
  errorType: text('error_type'), // 'no_results', 'provider_unavailable', 'extraction_failed'
  errorMessage: text('error_message'),

  // Metadata
  timestamp: timestamp('timestamp').notNull().defaultNow(),
  expiresAt: timestamp('expires_at').notNull()
    .$defaultFn(() => {
      const date = new Date();
      date.setDate(date.getDate() + 30);
      return date;
    }),
});

// Add type export
export type FailedSearchLog = InferSelectModel<typeof failedSearchLogs>;
```

2. Create `lib/db/queries/failed-search.ts`:

```typescript
import { db } from '@/lib/db';
import { failedSearchLogs } from '@/lib/db/schema';
import { desc, lt, and, gte, lte, or, ilike } from 'drizzle-orm';

export interface LogFailedSearchParams {
  chatId: string;
  userId: string;
  queryText: string;
  extractedOrigin?: string;
  extractedDestination?: string;
  departDate?: string;
  returnDate?: string;
  cabin?: string;
  resultCount: number;
  errorType?: string;
  errorMessage?: string;
}

export async function logFailedSearch(params: LogFailedSearchParams) {
  return db.insert(failedSearchLogs).values(params).returning();
}

export interface GetFailedSearchLogsParams {
  startDate?: Date;
  endDate?: Date;
  query?: string;
  limit?: number;
}

export async function getFailedSearchLogs(params: GetFailedSearchLogsParams = {}) {
  const { startDate, endDate, query, limit = 100 } = params;

  const conditions = [];

  if (startDate) {
    conditions.push(gte(failedSearchLogs.timestamp, startDate));
  }
  if (endDate) {
    conditions.push(lte(failedSearchLogs.timestamp, endDate));
  }
  if (query) {
    conditions.push(
      or(
        ilike(failedSearchLogs.queryText, `%${query}%`),
        ilike(failedSearchLogs.extractedOrigin, `%${query}%`),
        ilike(failedSearchLogs.extractedDestination, `%${query}%`)
      )
    );
  }

  return db
    .select()
    .from(failedSearchLogs)
    .where(conditions.length > 0 ? and(...conditions) : undefined)
    .orderBy(desc(failedSearchLogs.timestamp))
    .limit(limit);
}

export async function deleteExpiredLogs() {
  return db
    .delete(failedSearchLogs)
    .where(lt(failedSearchLogs.expiresAt, new Date()))
    .returning({ id: failedSearchLogs.id });
}
```

3. Export from `lib/db/queries/index.ts` if it exists, otherwise queries are used directly.
  </action>
  <verify>Run TypeScript check: `npx tsc --noEmit lib/db/schema.ts lib/db/queries/failed-search.ts`</verify>
  <done>Schema has failedSearchLogs table with TTL field, query functions exported for logging, retrieval, and cleanup</done>
</task>

<task type="auto">
  <name>Task 2: Integrate logging into flight-search.ts and add cron cleanup</name>
  <files>lib/tools/flight-search.ts, app/api/cron/cleanup-failed-searches/route.ts, vercel.json</files>
  <action>
1. In `lib/tools/flight-search.ts`, add import at top:
```typescript
import { logFailedSearch } from '@/lib/db/queries/failed-search';
```

2. In the `execute` function, after the `if (!hasSeats && !hasDuffel)` check at line ~244, BEFORE searching for alternatives, add logging. Insert right after line 248 (where errorType is determined):

```typescript
// Log the failed search for monitoring (non-blocking)
try {
  const userId = (messages as any)?.[0]?.userId || 'anonymous';
  await logFailedSearch({
    chatId,
    userId,
    queryText: fullQuery,
    extractedOrigin: origin,
    extractedDestination: destination,
    departDate: params.departDate,
    returnDate: params.returnDate || undefined,
    cabin: params.cabin,
    resultCount: 0,
    errorType,
    errorMessage: seatsError && duffelError ? 'Both providers failed' : undefined,
  });
  console.log('[Flight Search] Logged failed search to database');
} catch (logError) {
  console.warn('[Flight Search] Failed to log search failure (non-blocking):', logError);
}
```

3. Create `app/api/cron/cleanup-failed-searches/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { deleteExpiredLogs } from '@/lib/db/queries/failed-search';

export async function GET(request: NextRequest) {
  // Verify cron secret for security
  const authHeader = request.headers.get('Authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const deleted = await deleteExpiredLogs();
    console.log(`[Cron] Deleted ${deleted.length} expired failed search logs`);
    return NextResponse.json({
      success: true,
      deleted: deleted.length,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('[Cron] Failed to cleanup logs:', error);
    return NextResponse.json({
      error: 'Cleanup failed',
      message: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}
```

4. Update `vercel.json` to add the cleanup cron job (runs daily at 2 AM):

```json
{
  "crons": [
    {
      "path": "/api/clean_images",
      "schedule": "0 * * * *"
    },
    {
      "path": "/api/cron/awardwallet-sync",
      "schedule": "0 */6 * * *"
    },
    {
      "path": "/api/cron/cleanup-failed-searches",
      "schedule": "0 2 * * *"
    }
  ]
}
```
  </action>
  <verify>TypeScript check passes for modified files. Verify cron endpoint exists.</verify>
  <done>Failed searches logged on no-results, Vercel Cron configured for daily cleanup at 2 AM</done>
</task>

<task type="auto">
  <name>Task 3: Create admin UI for viewing failed search logs</name>
  <files>app/api/admin/failed-searches/route.ts, app/admin/failed-searches/page.tsx</files>
  <action>
1. Create `app/api/admin/failed-searches/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getUser, getUserRole } from '@/lib/auth-utils';
import { getFailedSearchLogs } from '@/lib/db/queries/failed-search';

export async function GET(request: NextRequest) {
  // Auth check - reuse existing admin pattern from layout.tsx
  const user = await getUser();
  if (!user) {
    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
  }

  const userRole = await getUserRole(user.id);
  if (userRole !== 'admin') {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  // Parse query params
  const { searchParams } = new URL(request.url);
  const startDate = searchParams.get('startDate');
  const endDate = searchParams.get('endDate');
  const query = searchParams.get('query');
  const limit = parseInt(searchParams.get('limit') || '100');

  try {
    const logs = await getFailedSearchLogs({
      startDate: startDate ? new Date(startDate) : undefined,
      endDate: endDate ? new Date(endDate) : undefined,
      query: query || undefined,
      limit,
    });

    return NextResponse.json({ logs, count: logs.length });
  } catch (error) {
    console.error('[Admin API] Failed to fetch logs:', error);
    return NextResponse.json({
      error: 'Failed to fetch logs'
    }, { status: 500 });
  }
}
```

2. Create `app/admin/failed-searches/page.tsx`:

```typescript
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow
} from '@/components/ui/table';
import { Search, Calendar, RefreshCw } from 'lucide-react';

interface FailedSearchLog {
  id: string;
  queryText: string;
  extractedOrigin: string | null;
  extractedDestination: string | null;
  departDate: string | null;
  cabin: string | null;
  errorType: string | null;
  timestamp: string;
}

export default function FailedSearchesPage() {
  const [logs, setLogs] = useState<FailedSearchLog[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchText, setSearchText] = useState('');
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');

  const fetchLogs = useCallback(async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (startDate) params.set('startDate', startDate);
      if (endDate) params.set('endDate', endDate);
      if (searchText) params.set('query', searchText);

      const res = await fetch(`/api/admin/failed-searches?${params}`);
      const data = await res.json();
      setLogs(data.logs || []);
    } catch (error) {
      console.error('Failed to fetch logs:', error);
    } finally {
      setLoading(false);
    }
  }, [startDate, endDate, searchText]);

  useEffect(() => {
    fetchLogs();
  }, [fetchLogs]);

  const formatDate = (dateStr: string) => {
    return new Date(dateStr).toLocaleString('de-DE', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">Fehlgeschlagene Suchen</h1>
        <Button onClick={fetchLogs} variant="outline" size="sm">
          <RefreshCw className="h-4 w-4 mr-2" />
          Aktualisieren
        </Button>
      </div>

      {/* Filters */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Filter</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="flex flex-wrap gap-4">
            <div className="flex-1 min-w-[200px]">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Suche in Queries..."
                  value={searchText}
                  onChange={(e) => setSearchText(e.target.value)}
                  className="pl-9"
                />
              </div>
            </div>
            <div className="flex gap-2 items-center">
              <Calendar className="h-4 w-4 text-muted-foreground" />
              <Input
                type="date"
                value={startDate}
                onChange={(e) => setStartDate(e.target.value)}
                className="w-[150px]"
              />
              <span className="text-muted-foreground">bis</span>
              <Input
                type="date"
                value={endDate}
                onChange={(e) => setEndDate(e.target.value)}
                className="w-[150px]"
              />
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Results Table */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg">
            {loading ? 'Laden...' : `${logs.length} Eintraege`}
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Zeitpunkt</TableHead>
                <TableHead>Query</TableHead>
                <TableHead>Route</TableHead>
                <TableHead>Datum</TableHead>
                <TableHead>Klasse</TableHead>
                <TableHead>Fehlertyp</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {logs.map((log) => (
                <TableRow key={log.id}>
                  <TableCell className="whitespace-nowrap">
                    {formatDate(log.timestamp)}
                  </TableCell>
                  <TableCell className="max-w-[200px] truncate" title={log.queryText}>
                    {log.queryText}
                  </TableCell>
                  <TableCell>
                    {log.extractedOrigin || '?'} â†’ {log.extractedDestination || '?'}
                  </TableCell>
                  <TableCell>{log.departDate || '-'}</TableCell>
                  <TableCell>{log.cabin || '-'}</TableCell>
                  <TableCell>
                    <span className={`px-2 py-1 rounded text-xs ${
                      log.errorType === 'no_results'
                        ? 'bg-yellow-100 text-yellow-800'
                        : 'bg-red-100 text-red-800'
                    }`}>
                      {log.errorType || 'unknown'}
                    </span>
                  </TableCell>
                </TableRow>
              ))}
              {logs.length === 0 && !loading && (
                <TableRow>
                  <TableCell colSpan={6} className="text-center text-muted-foreground py-8">
                    Keine fehlgeschlagenen Suchen gefunden
                  </TableCell>
                </TableRow>
              )}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
}
```

3. Update `components/admin/admin-nav.tsx` to add navigation link for the new page. Look at existing pattern and add:
```typescript
{ href: '/admin/failed-searches', label: 'Fehlgeschlagene Suchen', icon: AlertCircle }
```
Import AlertCircle from lucide-react.
  </action>
  <verify>
1. Navigate to /admin in browser, verify 'Fehlgeschlagene Suchen' appears in sidebar and links to /admin/failed-searches
2. Click link, verify page loads with filter controls and table structure
  </verify>
  <done>Admin can access /admin/failed-searches page via sidebar navigation, view logs with date range and text filters</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `npx tsc --noEmit` passes
2. Schema table exists: Grep for "failedSearchLogs" in schema.ts
3. Flight search integration: Grep for "logFailedSearch" in flight-search.ts
4. Cron job configured: Verify vercel.json contains cleanup-failed-searches path
5. Admin page accessible: Visit /admin/failed-searches (requires admin role)
</verification>

<success_criteria>
- failedSearchLogs table defined in schema with 30-day expiresAt default
- logFailedSearch() called when flight search returns no results
- Vercel Cron job configured to run daily at 2 AM
- Admin page shows logs with working date and text filters
- All TypeScript types valid
</success_criteria>

<output>
After completion, create `.planning/phases/03-observability-enhancement/03-01-SUMMARY.md`
</output>
