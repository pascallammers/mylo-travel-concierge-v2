---
phase: 01-llm-airport-resolution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/utils/llm-airport-resolver.ts
  - lib/utils/airport-codes.ts
autonomous: true

must_haves:
  truths:
    - "LLM extracts IATA codes from natural language queries"
    - "Context disambiguates ambiguous cities (liberia + costa rica = LIR)"
    - "Low confidence results are detected and flagged"
    - "Invalid inputs return structured error responses"
  artifacts:
    - path: "lib/utils/llm-airport-resolver.ts"
      provides: "extractAirportCodes function with xAI/Grok integration"
      exports: ["extractAirportCodes", "AirportExtractionResult", "AirportExtractionSchema"]
      min_lines: 80
    - path: "lib/utils/airport-codes.ts"
      provides: "Updated resolveAirportCodesWithLLM function"
      exports: ["resolveAirportCodesWithLLM"]
  key_links:
    - from: "lib/utils/llm-airport-resolver.ts"
      to: "ai/providers.ts"
      via: "xaiClient import"
      pattern: "createXai|xaiClient"
    - from: "lib/utils/llm-airport-resolver.ts"
      to: "zod"
      via: "schema definition"
      pattern: "z\\.object"
---

<objective>
Create LLM-based airport code extraction using xAI/Grok with structured outputs.

Purpose: Enable natural language airport resolution with contextual disambiguation (e.g., "costa rica liberia" -> LIR, not LIB). This replaces the brittle static mapping approach.

Output: Working `extractAirportCodes()` function that returns typed airport extraction results with confidence levels.
</objective>

<execution_context>
@/Users/pascallammers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pascallammers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-llm-airport-resolution/01-CONTEXT.md
@.planning/phases/01-llm-airport-resolution/01-RESEARCH.md
@lib/utils/airport-codes.ts
@lib/tools/text-translate.ts
@ai/providers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LLM airport resolver module</name>
  <files>lib/utils/llm-airport-resolver.ts</files>
  <action>
Create new file `lib/utils/llm-airport-resolver.ts` with:

1. **Zod Schema** for structured output:
```typescript
const AirportSchema = z.object({
  code: z.string().length(3).regex(/^[A-Z]{3}$/).describe('IATA airport code'),
  name: z.string().describe('Full airport name for display'),
  city: z.string().describe('City name'),
  country: z.string().describe('Country name'),
  confidence: z.enum(['high', 'medium', 'low']).describe('Extraction confidence'),
});

const AirportExtractionSchema = z.object({
  origin: AirportSchema.nullable().describe('Origin airport, null if not found'),
  destination: AirportSchema.nullable().describe('Destination airport, null if not found'),
  ambiguousOrigin: z.array(AirportSchema).optional().describe('Alternative options if origin ambiguous'),
  ambiguousDestination: z.array(AirportSchema).optional().describe('Alternative options if destination ambiguous'),
  reasoning: z.string().optional().describe('Disambiguation reasoning'),
});
```

2. **extractAirportCodes function**:
- Use `generateText` with `experimental_output: Output.object()` (pattern from text-translate.ts)
- Use xAI client directly via `createXai` for consistent Grok usage
- Model: `grok-4-fast-reasoning` (from providers.ts)
- Temperature: 0.1 (low for consistent extraction)
- MaxTokens: 500

3. **System prompt** (from RESEARCH.md):
- Disambiguation rules for liberia/costa rica, san jose, etc.
- Few-shot examples embedded in prompt
- Return confidence levels appropriately

4. **Error handling**:
- Catch `NoOutputGeneratedError` and return fallback
- Log extraction attempts with `[LLM Airport]` prefix
- Return typed result: `AirportExtractionResult`

5. **Types to export**:
- `AirportExtractionResult` (inferred from schema)
- `AirportExtractionSchema` (for testing)
- `extractAirportCodes` (main function)

Use the same `experimental_output` pattern from `text-translate.ts` for consistency with existing codebase patterns.
  </action>
  <verify>
```bash
npx tsc --noEmit lib/utils/llm-airport-resolver.ts
```
File compiles without errors.
  </verify>
  <done>
- File exists at lib/utils/llm-airport-resolver.ts
- Exports extractAirportCodes function
- Uses Zod schema with confidence levels
- Handles NoOutputGeneratedError gracefully
  </done>
</task>

<task type="auto">
  <name>Task 2: Add LLM-backed resolution to airport-codes.ts</name>
  <files>lib/utils/airport-codes.ts</files>
  <action>
Extend `lib/utils/airport-codes.ts` with new async resolution function:

1. **Add import** at top:
```typescript
import { extractAirportCodes } from './llm-airport-resolver';
```

2. **Add new async function** `resolveAirportCodesWithLLM`:
```typescript
export async function resolveAirportCodesWithLLM(query: string): Promise<AirportResolutionResult> {
  // Tier 1: Check if already valid IATA codes (e.g., "FRA to LIR")
  const directMatch = tryDirectCodeExtraction(query);
  if (directMatch) return directMatch;

  // Tier 2: Try static mapping for simple city names
  const staticResult = tryStaticMapping(query);
  if (staticResult && staticResult.confidence === 'high') return staticResult;

  // Tier 3: LLM extraction for complex/ambiguous queries
  const llmResult = await extractAirportCodes(query);
  return llmResult;
}
```

3. **Add helper functions**:
- `tryDirectCodeExtraction(query)`: Parse "FRA to LIR" or "FRA nach LIR" patterns
- `tryStaticMapping(query)`: Use existing AIRPORT_CODES for simple lookups
- Both return null if no confident match

4. **Add result type**:
```typescript
export type AirportResolutionResult = {
  origin: { code: string; name: string; confidence: 'high' | 'medium' | 'low' } | null;
  destination: { code: string; name: string; confidence: 'high' | 'medium' | 'low' } | null;
  needsClarification?: {
    type: 'origin' | 'destination' | 'both';
    options: Array<{ code: string; name: string; city: string; country: string }>;
  };
  error?: string;
};
```

5. **Keep existing functions** unchanged:
- `resolveIATACode()` (sync, used by existing code)
- `isValidIATACode()`
- `getCityNameForIATA()`

This allows gradual migration - existing code keeps working while new code can use the async LLM-backed version.
  </action>
  <verify>
```bash
npx tsc --noEmit lib/utils/airport-codes.ts
```
File compiles without errors. Existing exports still work.
  </verify>
  <done>
- resolveAirportCodesWithLLM function exported
- AirportResolutionResult type exported
- Tiered resolution: direct codes -> static mapping -> LLM
- Existing functions unchanged (backward compatible)
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation:
```bash
npx tsc --noEmit lib/utils/llm-airport-resolver.ts lib/utils/airport-codes.ts
```

2. Verify exports:
```bash
grep -E "^export (function|type|const|interface)" lib/utils/llm-airport-resolver.ts lib/utils/airport-codes.ts
```

3. Pattern verification:
```bash
grep -E "experimental_output|Output.object" lib/utils/llm-airport-resolver.ts
```
Should find structured output usage matching text-translate.ts pattern.
</verification>

<success_criteria>
- [ ] llm-airport-resolver.ts created with Zod schema and extractAirportCodes function
- [ ] airport-codes.ts has new resolveAirportCodesWithLLM async function
- [ ] Both files compile without TypeScript errors
- [ ] Disambiguation prompt includes costa rica/liberia and san jose examples
- [ ] Confidence levels (high/medium/low) are part of the response schema
- [ ] Error handling for LLM failures returns structured fallback
</success_criteria>

<output>
After completion, create `.planning/phases/01-llm-airport-resolution/01-01-SUMMARY.md`
</output>
