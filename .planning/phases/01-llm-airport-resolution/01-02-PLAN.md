---
phase: 01-llm-airport-resolution
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/performance-cache.ts
  - lib/tools/flight-search.ts
  - lib/api/duffel-client.ts
autonomous: true

must_haves:
  truths:
    - "Repeated queries hit cache (no redundant LLM calls)"
    - "User sees extracted airports in response: 'Suche Fluege: Frankfurt (FRA) -> San Jose (SJO)'"
    - "Ambiguous queries without context ask user to clarify with max 3 options"
    - "Response time for airport resolution is under 2 seconds"
    - "LLM failures fall back to static airport-codes.ts mapping"
  artifacts:
    - path: "lib/performance-cache.ts"
      provides: "Airport extraction cache"
      exports: ["airportExtractionCache", "createAirportKey"]
    - path: "lib/tools/flight-search.ts"
      provides: "Updated flight search using LLM resolution"
      contains: "resolveAirportCodesWithLLM"
    - path: "lib/api/duffel-client.ts"
      provides: "IATA code validation via Places API"
      exports: ["validateIATACode"]
  key_links:
    - from: "lib/tools/flight-search.ts"
      to: "lib/utils/airport-codes.ts"
      via: "resolveAirportCodesWithLLM import"
      pattern: "resolveAirportCodesWithLLM"
    - from: "lib/utils/airport-codes.ts"
      to: "lib/performance-cache.ts"
      via: "cache lookup"
      pattern: "airportExtractionCache"
---

<objective>
Integrate caching layer for LLM airport extraction and update flight search to use the new resolver.

Purpose: Make repeated queries fast (cache hit), handle ambiguous queries gracefully, and ensure the user always sees what airports were extracted before search runs.

Output: Working end-to-end flow where user searches "Frankfurt nach costa rica liberia" and gets correct FRA -> LIR extraction displayed before flight results.
</objective>

<execution_context>
@/Users/pascallammers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pascallammers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-llm-airport-resolution/01-CONTEXT.md
@.planning/phases/01-llm-airport-resolution/01-RESEARCH.md
@.planning/phases/01-llm-airport-resolution/01-01-SUMMARY.md
@lib/performance-cache.ts
@lib/tools/flight-search.ts
@lib/api/duffel-client.ts
@lib/utils/airport-codes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add airport extraction cache and Duffel validation</name>
  <files>lib/performance-cache.ts, lib/api/duffel-client.ts</files>
  <action>
**In lib/performance-cache.ts**, add airport extraction cache:

1. Add new cache instance after existing caches:
```typescript
// Airport extraction cache - 24h TTL, 500 entries
export const airportExtractionCache = new PerformanceCache<AirportExtractionCacheEntry>(
  'airport-extractions',
  500,
  24 * 60 * 60 * 1000  // 24 hours TTL
);

// Cache key generator
export const createAirportKey = (query: string) =>
  `airport:${query.toLowerCase().trim().replace(/\s+/g, '-')}`;
```

2. Add type for cache entry (import from airport-codes.ts or define inline):
```typescript
interface AirportExtractionCacheEntry {
  origin: { code: string; name: string; confidence: string } | null;
  destination: { code: string; name: string; confidence: string } | null;
  cachedAt: number;
}
```

**In lib/api/duffel-client.ts**, add IATA validation function:

1. Add at end of file:
```typescript
/**
 * Validate IATA code exists using Duffel Places API
 * @param code - IATA code to validate
 * @returns true if valid airport code
 */
export async function validateIATACode(code: string): Promise<boolean> {
  const duffel = getDuffelClient();

  try {
    const response = await duffel.places.list({ query: code });
    return response.data.some(
      (place: any) => place.type === 'airport' && place.iata_code === code
    );
  } catch (error) {
    console.warn('[Duffel] IATA validation failed, assuming valid:', code, error);
    return true; // Fail open - don't block on validation errors
  }
}
```

This validation is used for low-confidence LLM extractions to verify the code exists.
  </action>
  <verify>
```bash
npx tsc --noEmit lib/performance-cache.ts lib/api/duffel-client.ts
```
Both files compile without errors.
  </verify>
  <done>
- airportExtractionCache exported from performance-cache.ts
- createAirportKey helper exported
- validateIATACode function added to duffel-client.ts
- 24-hour TTL configured for airport cache
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate cache into airport resolution</name>
  <files>lib/utils/airport-codes.ts</files>
  <action>
Update `lib/utils/airport-codes.ts` to use caching:

1. Add imports at top:
```typescript
import { airportExtractionCache, createAirportKey } from '@/lib/performance-cache';
import { validateIATACode } from '@/lib/api/duffel-client';
```

2. Update `resolveAirportCodesWithLLM` to include cache:
```typescript
export async function resolveAirportCodesWithLLM(query: string): Promise<AirportResolutionResult> {
  // Tier 1: Check if already valid IATA codes
  const directMatch = tryDirectCodeExtraction(query);
  if (directMatch) return directMatch;

  // Tier 2: Cache lookup
  const cacheKey = createAirportKey(query);
  const cached = airportExtractionCache.get(cacheKey);
  if (cached) {
    console.log('[Airport] Cache hit:', cacheKey);
    return cached;
  }

  // Tier 3: Try static mapping for simple city names
  const staticResult = tryStaticMapping(query);
  if (staticResult && staticResult.origin?.confidence === 'high' && staticResult.destination?.confidence === 'high') {
    airportExtractionCache.set(cacheKey, staticResult);
    return staticResult;
  }

  // Tier 4: LLM extraction
  console.log('[Airport] LLM extraction for:', query);
  const llmResult = await extractAirportCodes(query);

  // Tier 5: Validate low-confidence results
  if (llmResult.origin?.confidence === 'low' && llmResult.origin?.code) {
    const valid = await validateIATACode(llmResult.origin.code);
    if (!valid) {
      llmResult.origin = null;
      llmResult.needsClarification = { type: 'origin', options: llmResult.ambiguousOrigin || [] };
    }
  }

  // Cache successful extractions (not low-confidence)
  if (llmResult.origin?.confidence !== 'low' && llmResult.destination?.confidence !== 'low') {
    airportExtractionCache.set(cacheKey, llmResult);
  }

  return llmResult;
}
```

3. Add timeout wrapper (2s max for resolution):
```typescript
const LLM_TIMEOUT_MS = 2000;

async function extractWithTimeout(query: string): Promise<AirportExtractionResult> {
  const timeoutPromise = new Promise<never>((_, reject) =>
    setTimeout(() => reject(new Error('LLM timeout')), LLM_TIMEOUT_MS)
  );

  return Promise.race([extractAirportCodes(query), timeoutPromise]);
}
```

Use `extractWithTimeout` instead of direct `extractAirportCodes` call in the resolution function.
  </action>
  <verify>
```bash
npx tsc --noEmit lib/utils/airport-codes.ts
```
File compiles without errors.
  </verify>
  <done>
- Cache lookup before LLM call
- Cache set after successful extraction
- Low-confidence results validated via Duffel API
- 2-second timeout on LLM calls
  </done>
</task>

<task type="auto">
  <name>Task 3: Update flight-search.ts to use LLM resolver</name>
  <files>lib/tools/flight-search.ts</files>
  <action>
Update `lib/tools/flight-search.ts` to use the new async resolver:

1. **Update import**:
```typescript
// Remove: import { resolveIATACode } from '@/lib/utils/airport-codes';
// Add:
import { resolveAirportCodesWithLLM, resolveIATACode, AirportResolutionResult } from '@/lib/utils/airport-codes';
```

2. **Update the execute function** to handle async resolution:

Replace the simple resolution block (around line 125-133):
```typescript
// OLD:
const origin = resolveIATACode(params.origin);
const destination = resolveIATACode(params.destination);
```

With new async resolution:
```typescript
// NEW: Build full query for context-aware extraction
const fullQuery = `${params.origin} nach ${params.destination}`;
console.log('[Flight Search] Resolving airports from query:', fullQuery);

const resolution = await resolveAirportCodesWithLLM(fullQuery);

// Handle clarification needed
if (resolution.needsClarification) {
  const clarifyType = resolution.needsClarification.type;
  const options = resolution.needsClarification.options
    .slice(0, 3)
    .map(opt => `${opt.code} - ${opt.name} (${opt.city}, ${opt.country})`)
    .join('\n');

  return {
    type: 'clarification_needed',
    message: `Ich brauche eine Klarstellung fÃ¼r ${clarifyType === 'origin' ? 'den Abflugort' : 'das Ziel'}:`,
    options: resolution.needsClarification.options.slice(0, 3),
    displayText: `Meinten Sie:\n${options}`,
  };
}

// Extract codes or fall back to sync resolver
const origin = resolution.origin?.code || resolveIATACode(params.origin);
const destination = resolution.destination?.code || resolveIATACode(params.destination);

// Display extracted airports to user (per CONTEXT.md decision)
const originDisplay = resolution.origin
  ? `${resolution.origin.name} (${resolution.origin.code})`
  : origin;
const destinationDisplay = resolution.destination
  ? `${resolution.destination.name} (${resolution.destination.code})`
  : destination;

console.log(`[Flight Search] Suche Fluege: ${originDisplay} -> ${destinationDisplay}`);
```

3. **Update result formatting** to include extracted airport info:

In the returned result object, add:
```typescript
extractedAirports: {
  origin: originDisplay,
  destination: destinationDisplay,
},
```

4. **Keep sync fallback** for edge cases:
If LLM extraction fails completely, the existing `resolveIATACode` function is still called as fallback.
  </action>
  <verify>
```bash
npx tsc --noEmit lib/tools/flight-search.ts
```
File compiles without errors.

Manual test (requires running app):
- Search "Frankfurt nach costa rica liberia"
- Should see "Suche Fluege: Frankfurt (FRA) -> Daniel Oduber (LIR)" in logs
  </verify>
  <done>
- flight-search.ts uses resolveAirportCodesWithLLM
- Clarification response returned for ambiguous queries
- Extracted airports displayed in logs
- Fallback to sync resolveIATACode on LLM failure
  </done>
</task>

</tasks>

<verification>
1. Full TypeScript check:
```bash
npx tsc --noEmit
```

2. Verify cache integration:
```bash
grep -n "airportExtractionCache" lib/utils/airport-codes.ts lib/performance-cache.ts
```

3. Verify flight-search uses new resolver:
```bash
grep -n "resolveAirportCodesWithLLM" lib/tools/flight-search.ts
```

4. Verify validateIATACode export:
```bash
grep -n "validateIATACode" lib/api/duffel-client.ts
```
</verification>

<success_criteria>
- [ ] airportExtractionCache exported from performance-cache.ts with 24h TTL
- [ ] validateIATACode function exported from duffel-client.ts
- [ ] airport-codes.ts uses cache before LLM call
- [ ] 2-second timeout on LLM extraction
- [ ] flight-search.ts returns clarification response for ambiguous queries
- [ ] Extracted airports displayed in format "Suche Fluege: X (XXX) -> Y (YYY)"
- [ ] Full project compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-llm-airport-resolution/01-02-SUMMARY.md`
</output>
