---
phase: 01-llm-airport-resolution
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/performance-cache.ts
  - lib/tools/flight-search.ts
  - lib/api/duffel-client.ts
  - lib/utils/airport-codes.ts
autonomous: true

must_haves:
  truths:
    - "Repeated queries hit cache (no redundant LLM calls)"
    - "User sees extracted airports in response: 'Suche Fluege: Frankfurt (FRA) -> San Jose (SJO)'"
    - "Ambiguous queries without context ask user to clarify with max 3 options"
    - "Response time for airport resolution is under 2 seconds"
    - "LLM failures fall back to static airport-codes.ts mapping"
    - "User can correct recognized airports via text input after extraction"
    - "Corrections are cached to improve future suggestions"
  artifacts:
    - path: "lib/performance-cache.ts"
      provides: "Airport extraction cache with correction support"
      exports: ["airportExtractionCache", "airportCorrectionCache", "createAirportKey"]
    - path: "lib/tools/flight-search.ts"
      provides: "Updated flight search using LLM resolution"
      contains: "resolveAirportCodesWithLLM"
    - path: "lib/api/duffel-client.ts"
      provides: "IATA code validation via Places API"
      exports: ["validateIATACode"]
    - path: "lib/utils/airport-codes.ts"
      provides: "Correction detection and application"
      exports: ["applyCorrectionIfDetected", "storeCorrectionMapping"]
  key_links:
    - from: "lib/tools/flight-search.ts"
      to: "lib/utils/airport-codes.ts"
      via: "resolveAirportCodesWithLLM import"
      pattern: "resolveAirportCodesWithLLM"
    - from: "lib/utils/airport-codes.ts"
      to: "lib/performance-cache.ts"
      via: "cache lookup and correction cache"
      pattern: "airportExtractionCache|airportCorrectionCache"
---

<objective>
Integrate caching layer for LLM airport extraction and update flight search to use the new resolver.

Purpose: Make repeated queries fast (cache hit), handle ambiguous queries gracefully, and ensure the user always sees what airports were extracted before search runs.

Output: Working end-to-end flow where user searches "Frankfurt nach costa rica liberia" and gets correct FRA -> LIR extraction displayed before flight results.
</objective>

<execution_context>
@/Users/pascallammers/.claude/get-shit-done/workflows/execute-plan.md
@/Users/pascallammers/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-llm-airport-resolution/01-CONTEXT.md
@.planning/phases/01-llm-airport-resolution/01-RESEARCH.md
@.planning/phases/01-llm-airport-resolution/01-01-SUMMARY.md
@lib/performance-cache.ts
@lib/tools/flight-search.ts
@lib/api/duffel-client.ts
@lib/utils/airport-codes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add airport extraction cache and Duffel validation</name>
  <files>lib/performance-cache.ts, lib/api/duffel-client.ts</files>
  <action>
**In lib/performance-cache.ts**, add airport extraction cache:

1. Add new cache instances after existing caches:
```typescript
// Airport extraction cache - 24h TTL, 500 entries
export const airportExtractionCache = new PerformanceCache<AirportExtractionCacheEntry>(
  'airport-extractions',
  500,
  24 * 60 * 60 * 1000  // 24 hours TTL
);

// User correction cache - stores user-validated corrections to influence future extractions
// Key: normalized original query pattern, Value: corrected IATA code
export const airportCorrectionCache = new PerformanceCache<AirportCorrectionEntry>(
  'airport-corrections',
  200,
  7 * 24 * 60 * 60 * 1000  // 7 days TTL - corrections are valuable long-term
);

// Cache key generator
export const createAirportKey = (query: string) =>
  `airport:${query.toLowerCase().trim().replace(/\s+/g, '-')}`;
```

2. Add types for cache entries (import from airport-codes.ts or define inline):
```typescript
interface AirportExtractionCacheEntry {
  origin: { code: string; name: string; confidence: string } | null;
  destination: { code: string; name: string; confidence: string } | null;
  cachedAt: number;
}

interface AirportCorrectionEntry {
  originalQuery: string;      // e.g., "liberia costa rica"
  extractedCode: string;      // what LLM originally extracted: "LIB"
  correctedCode: string;      // what user corrected to: "LIR"
  correctedAt: number;
}
```

**In lib/api/duffel-client.ts**, add IATA validation function:

1. Add at end of file:
```typescript
/**
 * Validate IATA code exists using Duffel Places API
 * @param code - IATA code to validate
 * @returns true if valid airport code
 */
export async function validateIATACode(code: string): Promise<boolean> {
  const duffel = getDuffelClient();

  try {
    const response = await duffel.places.list({ query: code });
    return response.data.some(
      (place: any) => place.type === 'airport' && place.iata_code === code
    );
  } catch (error) {
    console.warn('[Duffel] IATA validation failed, assuming valid:', code, error);
    return true; // Fail open - don't block on validation errors
  }
}
```

This validation is used for low-confidence LLM extractions to verify the code exists.
  </action>
  <verify>
```bash
npx tsc --noEmit lib/performance-cache.ts lib/api/duffel-client.ts
```
Both files compile without errors.
  </verify>
  <done>
- airportExtractionCache exported from performance-cache.ts
- createAirportKey helper exported
- validateIATACode function added to duffel-client.ts
- 24-hour TTL configured for airport cache
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate cache into airport resolution</name>
  <files>lib/utils/airport-codes.ts</files>
  <action>
Update `lib/utils/airport-codes.ts` to use caching:

1. Add imports at top:
```typescript
import { airportExtractionCache, createAirportKey } from '@/lib/performance-cache';
import { validateIATACode } from '@/lib/api/duffel-client';
```

2. Update `resolveAirportCodesWithLLM` to include cache:
```typescript
export async function resolveAirportCodesWithLLM(query: string): Promise<AirportResolutionResult> {
  // Tier 1: Check if already valid IATA codes
  const directMatch = tryDirectCodeExtraction(query);
  if (directMatch) return directMatch;

  // Tier 2: Cache lookup
  const cacheKey = createAirportKey(query);
  const cached = airportExtractionCache.get(cacheKey);
  if (cached) {
    console.log('[Airport] Cache hit:', cacheKey);
    return cached;
  }

  // Tier 3: Try static mapping for simple city names
  const staticResult = tryStaticMapping(query);
  if (staticResult && staticResult.origin?.confidence === 'high' && staticResult.destination?.confidence === 'high') {
    airportExtractionCache.set(cacheKey, staticResult);
    return staticResult;
  }

  // Tier 4: LLM extraction
  console.log('[Airport] LLM extraction for:', query);
  const llmResult = await extractAirportCodes(query);

  // Tier 5: Validate low-confidence results
  if (llmResult.origin?.confidence === 'low' && llmResult.origin?.code) {
    const valid = await validateIATACode(llmResult.origin.code);
    if (!valid) {
      llmResult.origin = null;
      llmResult.needsClarification = { type: 'origin', options: llmResult.ambiguousOrigin || [] };
    }
  }

  // Cache successful extractions (not low-confidence)
  if (llmResult.origin?.confidence !== 'low' && llmResult.destination?.confidence !== 'low') {
    airportExtractionCache.set(cacheKey, llmResult);
  }

  return llmResult;
}
```

3. Add timeout wrapper (2s max for resolution):
```typescript
const LLM_TIMEOUT_MS = 2000;

async function extractWithTimeout(query: string): Promise<AirportExtractionResult> {
  const timeoutPromise = new Promise<never>((_, reject) =>
    setTimeout(() => reject(new Error('LLM timeout')), LLM_TIMEOUT_MS)
  );

  return Promise.race([extractAirportCodes(query), timeoutPromise]);
}
```

Use `extractWithTimeout` instead of direct `extractAirportCodes` call in the resolution function.
  </action>
  <verify>
```bash
npx tsc --noEmit lib/utils/airport-codes.ts
```
File compiles without errors.
  </verify>
  <done>
- Cache lookup before LLM call
- Cache set after successful extraction
- Low-confidence results validated via Duffel API
- 2-second timeout on LLM calls
  </done>
</task>

<task type="auto">
  <name>Task 3: Update flight-search.ts to use LLM resolver</name>
  <files>lib/tools/flight-search.ts</files>
  <action>
Update `lib/tools/flight-search.ts` to use the new async resolver:

1. **Update import**:
```typescript
// Remove: import { resolveIATACode } from '@/lib/utils/airport-codes';
// Add:
import { resolveAirportCodesWithLLM, resolveIATACode, AirportResolutionResult } from '@/lib/utils/airport-codes';
```

2. **Update the execute function** to handle async resolution:

Replace the simple resolution block (around line 125-133):
```typescript
// OLD:
const origin = resolveIATACode(params.origin);
const destination = resolveIATACode(params.destination);
```

With new async resolution:
```typescript
// NEW: Build full query for context-aware extraction
const fullQuery = `${params.origin} nach ${params.destination}`;
console.log('[Flight Search] Resolving airports from query:', fullQuery);

const resolution = await resolveAirportCodesWithLLM(fullQuery);

// Handle clarification needed
if (resolution.needsClarification) {
  const clarifyType = resolution.needsClarification.type;
  const options = resolution.needsClarification.options
    .slice(0, 3)
    .map(opt => `${opt.code} - ${opt.name} (${opt.city}, ${opt.country})`)
    .join('\n');

  return {
    type: 'clarification_needed',
    message: `Ich brauche eine Klarstellung für ${clarifyType === 'origin' ? 'den Abflugort' : 'das Ziel'}:`,
    options: resolution.needsClarification.options.slice(0, 3),
    displayText: `Meinten Sie:\n${options}`,
  };
}

// Extract codes or fall back to sync resolver
const origin = resolution.origin?.code || resolveIATACode(params.origin);
const destination = resolution.destination?.code || resolveIATACode(params.destination);

// Display extracted airports to user (per CONTEXT.md decision)
const originDisplay = resolution.origin
  ? `${resolution.origin.name} (${resolution.origin.code})`
  : origin;
const destinationDisplay = resolution.destination
  ? `${resolution.destination.name} (${resolution.destination.code})`
  : destination;

console.log(`[Flight Search] Suche Fluege: ${originDisplay} -> ${destinationDisplay}`);
```

3. **Update result formatting** to include extracted airport info:

In the returned result object, add:
```typescript
extractedAirports: {
  origin: originDisplay,
  destination: destinationDisplay,
},
```

4. **Keep sync fallback** for edge cases:
If LLM extraction fails completely, the existing `resolveIATACode` function is still called as fallback.
  </action>
  <verify>
```bash
npx tsc --noEmit lib/tools/flight-search.ts
```
File compiles without errors.

Manual test (requires running app):
- Search "Frankfurt nach costa rica liberia"
- Should see "Suche Fluege: Frankfurt (FRA) -> Daniel Oduber (LIR)" in logs
  </verify>
  <done>
- flight-search.ts uses resolveAirportCodesWithLLM
- Clarification response returned for ambiguous queries
- Extracted airports displayed in logs
- Fallback to sync resolveIATACode on LLM failure
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement user correction flow with caching</name>
  <files>lib/utils/airport-codes.ts, lib/tools/flight-search.ts</files>
  <action>
**Per locked user decision:** "User kann erkannte Flughäfen per Freitext-Eingabe korrigieren" and "Korrekturen im Cache merken für bessere zukünftige Vorschläge"

This task adds the ability for users to correct extracted airports via follow-up messages.

**In lib/utils/airport-codes.ts**, add correction handling:

1. Add import at top:
```typescript
import { airportCorrectionCache } from '@/lib/performance-cache';
```

2. Add correction detection function:
```typescript
/**
 * Detects if a user message is correcting a previous airport extraction.
 * Patterns: "nein, ich meinte LIR", "nicht LIB sondern LIR", "korrektur: LIR"
 * @param message - User's follow-up message
 * @param previousExtraction - The previous extraction result to correct
 * @returns Corrected result or null if not a correction
 */
export function detectCorrectionIntent(
  message: string,
  previousExtraction: AirportResolutionResult | null
): { type: 'origin' | 'destination'; correctedCode: string } | null {
  if (!previousExtraction) return null;

  const correctionPatterns = [
    /(?:nein|nicht|falsch)[,\s]+(?:ich meinte?|sondern|das ist)\s+([A-Z]{3})/i,
    /korrektur[:\s]+([A-Z]{3})/i,
    /(?:eigentlich|richtig ist)\s+([A-Z]{3})/i,
    /^([A-Z]{3})$/,  // Just the code alone as a correction
  ];

  for (const pattern of correctionPatterns) {
    const match = message.match(pattern);
    if (match) {
      const correctedCode = match[1].toUpperCase();
      // Determine if correcting origin or destination based on context
      const type = inferCorrectionTarget(previousExtraction, correctedCode);
      return { type, correctedCode };
    }
  }
  return null;
}

function inferCorrectionTarget(
  previous: AirportResolutionResult,
  correctedCode: string
): 'origin' | 'destination' {
  // If previous had needsClarification, use that
  if (previous.needsClarification?.type) {
    return previous.needsClarification.type;
  }
  // Default to destination (most common correction case)
  return 'destination';
}
```

3. Add correction storage function:
```typescript
/**
 * Stores a user correction to influence future extractions.
 * When LLM extracts LIB but user corrects to LIR for "liberia costa rica",
 * this mapping is cached so future similar queries prefer LIR.
 */
export function storeCorrectionMapping(
  originalQuery: string,
  extractedCode: string,
  correctedCode: string
): void {
  const key = createAirportKey(originalQuery);
  airportCorrectionCache.set(key, {
    originalQuery: originalQuery.toLowerCase(),
    extractedCode,
    correctedCode,
    correctedAt: Date.now(),
  });
  console.log(`[Airport] Stored correction: "${originalQuery}" ${extractedCode} -> ${correctedCode}`);
}
```

4. Add correction lookup to `resolveAirportCodesWithLLM`:
```typescript
// After cache lookup, before LLM call:
// Check if we have a user correction that applies
const correctionKey = createAirportKey(query);
const correction = airportCorrectionCache.get(correctionKey);
if (correction) {
  console.log(`[Airport] Applying previous user correction: ${correction.extractedCode} -> ${correction.correctedCode}`);
  // Apply correction to result
}
```

**In lib/tools/flight-search.ts**, add correction handling:

1. Add correction detection to the execute function:

Before the main resolution logic, check if this is a correction message:
```typescript
// Check if user is correcting a previous extraction
import { detectCorrectionIntent, storeCorrectionMapping } from '@/lib/utils/airport-codes';

// In execute function, before resolveAirportCodesWithLLM call:
const correctionIntent = detectCorrectionIntent(userMessage, previousExtractionFromContext);

if (correctionIntent) {
  // Apply the correction
  const correctedCode = correctionIntent.correctedCode;
  const isValid = await validateIATACode(correctedCode);

  if (!isValid) {
    return {
      type: 'error',
      message: `Der IATA-Code "${correctedCode}" existiert nicht. Bitte versuchen Sie es erneut.`,
    };
  }

  // Store correction for future use
  if (previousExtractionFromContext) {
    const originalCode = correctionIntent.type === 'origin'
      ? previousExtractionFromContext.origin?.code
      : previousExtractionFromContext.destination?.code;
    if (originalCode) {
      storeCorrectionMapping(originalQuery, originalCode, correctedCode);
    }
  }

  // Re-run search with corrected code
  // ... proceed with flight search using correctedCode
}
```

2. Store extraction result in conversation context for potential correction:
```typescript
// After successful extraction, before flight search:
// Store for potential correction (implementation depends on conversation state management)
```

Note: The exact implementation of "previousExtractionFromContext" depends on how conversation state is managed (likely via Convex or session state). The key pattern is: detect correction -> validate -> store -> re-search.
  </action>
  <verify>
```bash
npx tsc --noEmit lib/utils/airport-codes.ts lib/tools/flight-search.ts
```
Both files compile without errors.

Check exports:
```bash
grep -E "detectCorrectionIntent|storeCorrectionMapping" lib/utils/airport-codes.ts
```
  </verify>
  <done>
- detectCorrectionIntent function exported from airport-codes.ts
- storeCorrectionMapping function exported from airport-codes.ts
- Correction patterns detect German phrases like "nein, ich meinte", "nicht...sondern"
- Corrections stored in airportCorrectionCache with 7-day TTL
- flight-search.ts checks for correction intent before new resolution
- Stored corrections influence future extractions for same query patterns
  </done>
</task>

</tasks>

<verification>
1. Full TypeScript check:
```bash
npx tsc --noEmit
```

2. Verify cache integration:
```bash
grep -n "airportExtractionCache\|airportCorrectionCache" lib/utils/airport-codes.ts lib/performance-cache.ts
```

3. Verify flight-search uses new resolver:
```bash
grep -n "resolveAirportCodesWithLLM" lib/tools/flight-search.ts
```

4. Verify validateIATACode export:
```bash
grep -n "validateIATACode" lib/api/duffel-client.ts
```

5. Verify correction handling exports:
```bash
grep -n "detectCorrectionIntent\|storeCorrectionMapping" lib/utils/airport-codes.ts
```

6. Verify correction patterns:
```bash
grep -n "correctionPatterns\|nein.*meinte" lib/utils/airport-codes.ts
```
</verification>

<success_criteria>
- [ ] airportExtractionCache exported from performance-cache.ts with 24h TTL
- [ ] airportCorrectionCache exported from performance-cache.ts with 7-day TTL
- [ ] validateIATACode function exported from duffel-client.ts
- [ ] airport-codes.ts uses cache before LLM call
- [ ] 2-second timeout on LLM extraction
- [ ] flight-search.ts returns clarification response for ambiguous queries
- [ ] Extracted airports displayed in format "Suche Fluege: X (XXX) -> Y (YYY)"
- [ ] detectCorrectionIntent function detects user corrections in follow-up messages
- [ ] storeCorrectionMapping stores corrections to influence future extractions
- [ ] Correction cache is consulted before LLM extraction
- [ ] Full project compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-llm-airport-resolution/01-02-SUMMARY.md`
</output>
